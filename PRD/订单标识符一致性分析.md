# 订单标识符一致性问题分析

## 问题概述

当前代码中存在**3套订单标识符**，使用方式不一致：

| 标识符类型 | 用途 | 包含字段 |
|-----------|------|----------|
| `OrderNavParams` | 导航参数传递 | orderId, planId |
| `OrderInfoRequestModel` | 业务层/API请求 | orderId, planId |
| `Long orderId` | Repository缓存/Room主键 | 仅orderId |

---

## 关键问题

### 1. 数据库设计
```kotlin
// OrderEntity.kt - orderId是主键，planId只是普通字段
@PrimaryKey
val orderId: Long

@ColumnInfo(name = "plan_id")
val planId: Int = 0  // ⚠️ 未作为复合主键
```

### 2. 缓存设计
```kotlin
// UnifiedOrderRepository.kt - 仅用orderId作为缓存Key
private val _cachedOrderInfo = ConcurrentHashMap<Long, ServiceOrderInfoModel>()
//                                              ^^^^ 只有orderId
```

### 3. 业务层调用
```kotlin
// 多处创建时 planId 硬编码为 0
OrderInfoRequestModel(orderId = orderId, planId = 0)  // ⚠️ planId被忽略
```

---

## 业务确认问题

> [!IMPORTANT]
> **需要明确`planId`的业务含义：**
> 1. `planId`是否可能为不同值？（同一orderId是否对应多个plan？）
> 2. API请求时`planId`是否影响返回结果？
> 3. 同一`orderId`不同`planId`是否需要独立缓存？

---

## 解决方案

### 方案A: 统一使用orderId（如果planId不重要）

如果业务上`planId`总是0或不影响数据，则：
- 移除`OrderInfoRequestModel`，统一使用`Long orderId`
- 保持`OrderNavParams`用于导航（因为序列化需要）
- 保持当前数据库/缓存设计

**影响范围**：~15个文件，主要是ViewModel方法签名

---

### 方案B: 统一使用orderId+planId复合标识（如果planId重要）

如果业务上`orderId+planId`才能唯一标识订单，则：

1. **创建统一标识类**
```kotlin
data class OrderId(
    val orderId: Long,
    val planId: Int = 0
) {
    val cacheKey: String get() = "${orderId}_${planId}"
}
```

2. **修改数据库主键为复合主键**
```kotlin
@Entity(primaryKeys = ["order_id", "plan_id"])
```

3. **修改缓存Key**
```kotlin
private val _cachedOrderInfo = ConcurrentHashMap<String, ServiceOrderInfoModel>()
// 使用 "${orderId}_${planId}" 作为Key
```

**影响范围**：~25个文件，涉及数据库迁移

---

## 建议

请先确认业务场景中`planId`的实际作用，再决定采用哪种方案。
