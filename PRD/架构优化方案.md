# 护理服务App架构优化方案

## 一、当前问题分析

### 1.1 本地存储现状问题

当前项目存在多个本地存储方案混用的情况，导致数据管理混乱：

| 存储方案 | 使用位置 | 存储内容 | 问题 |
|---------|---------|---------|------|
| SharedPreferences (`order_storage`) | `ServiceTimeManager`, `SelectedProjectsManager`, `UploadedImagesManager`, `FaceVerificationStatusManager` | 服务时间、选中项目、已上传图片、人脸验证状态 | 数据分散，难以统一管理 |
| SharedPreferences (`device_instance_id_store`) | `DeviceUtils` | 设备ID | 合理 |
| SharedPreferences (其他) | `PendingOrdersStorage`, `ServiceTimeNotificationManager`, `CountdownBackupWorker` | 待处理订单、通知状态 | 缺乏统一设计 |
| DataStore | `AppDataStore` | 应用配置 | 仅定义未充分使用 |
| Room | 已引入依赖 | - | **未使用** |
| 内存缓存 | `SharedOrderRepository` | 订单详情 | 易丢失，无持久化 |

**核心问题：**
1. **数据分散**: 订单相关数据分布在多个Manager中，缺乏统一的数据模型
2. **图片状态不一致**: `UploadedImagesManager` 使用JSON序列化存储图片列表，容易导致状态与实际不符
3. **取消/重传问题**: 用户取消上传后重新上传，旧的图片Key可能仍然保留在存储中
4. **类型混乱**: 图片类型（客户照片、服务前、服务中、服务后）管理不清晰
5. **订单数据来源不一致**: 当前 `SharedOrderRepository` 使用内存Map缓存，页面间传递完整 `OrderInfoRequestModel` 对象

### 1.2 当前订单数据流问题

```
┌─────────────────────────────────────────────────────────────┐
│                    当前架构（问题）                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  页面A ───(OrderInfoRequestModel)───> 页面B                  │
│           ↑                              ↓                   │
│    SharedOrderRepository          SharedOrderRepository      │
│    (内存Map缓存)                   (内存Map缓存)              │
│           ↑                              ↑                   │
│         API                            API                   │
│                                                              │
│  问题：                                                       │
│  1. 页面间传递完整对象，包含 orderId + planId                  │
│  2. 多个页面各自调用API，缓存可能不一致                        │
│  3. 应用被杀死后，数据丢失                                    │
│  4. 各Manager各自存储部分数据，难以统一清理                    │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 定位服务现状问题

当前定位获取采用**单次请求模式**：

```kotlin
// AmapLocationManager.kt
val option = AMapLocationClientOption().apply {
    isOnceLocation = true        // 单次定位
    httpTimeOut = 20000          // 20秒超时
}
```

**问题：**
1. **延迟问题**: 每次需要定位时都发起新请求，GPS冷启动可能需要10-30秒
2. **位置不实时**: NFC签到时获取的位置可能已过时
3. **失败率高**: 单次请求模式在信号弱时容易失败

## 二、优化方案设计

### 2.1 订单数据同步架构（核心设计）

> [!IMPORTANT]
> **核心原则**：订单详细数据来源于服务端，Room数据库作为唯一本地数据源。API拉取时同步更新数据库，所有使用方从数据库获取，页面间只传递 `orderId`。

#### 目标架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      新架构（解决方案）                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                          ┌──────────┐                            │
│                          │   API    │                            │
│                          └────┬─────┘                            │
│                               ↓                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │            OrderRepository (统一数据仓库)                  │   │
│  │  ┌─────────────────────────────────────────────────────┐ │   │
│  │  │ 1. 调用API获取订单数据                                │ │   │
│  │  │ 2. 同步写入Room数据库                                 │ │   │
│  │  │ 3. 返回Flow<OrderEntity>供UI订阅                     │ │   │
│  │  └─────────────────────────────────────────────────────┘ │   │
│  └────────────────────────┬─────────────────────────────────┘   │
│                           ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │            Room Database (唯一本地数据源)                  │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐   │   │
│  │  │ OrderEntity │  │ ImageEntity │  │ LocationEntity  │   │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘   │   │
│  └────────────────────────┬─────────────────────────────────┘   │
│                           ↓                                      │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │     页面A ───(orderId)───> 页面B ───(orderId)───> 页面C   │   │
│  │              ↓                  ↓                  ↓      │   │
│  │        从DB获取数据        从DB获取数据       从DB获取数据  │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  优势：                                                           │
│  1. 数据来源唯一，避免不一致                                       │
│  2. 页面间只传orderId，导航简化                                    │
│  3. 应用被杀死后数据不丢失                                         │
│  4. 支持离线访问已缓存数据                                         │
└─────────────────────────────────────────────────────────────────┘
```

#### 核心实体设计

> [!IMPORTANT]
> **设计原则**：
> 1. 避免使用JSON字段，使用关联表保证查询效率和数据完整性
> 2. **单一职责原则**：每个表只存储一类数据，便于独立更新维护
> 3. 所有字段使用 `@ColumnInfo` 注解明确列名和默认值，防止混淆问题
> 4. 根据业务查询场景规划索引

##### 数据库ER图

```
┌─────────────────────┐       ┌─────────────────────────┐
│     OrderEntity     │───1:1─│  OrderElderInfoEntity   │
│   (订单核心信息)      │       │   (老人信息表)           │
├─────────────────────┤       ├─────────────────────────┤
│ PK: order_id        │       │ PK/FK: order_id         │
│ plan_id [索引]       │       │ elder_user_id [索引]     │
│ state [索引]         │       │ elder_name              │
│ start_time          │       │ elder_address           │
│ end_time            │       │ elder_lng, elder_lat    │
│ last_sync_time      │       │ month_service_time      │
└─────────────────────┘       └─────────────────────────┘
         │                              │
         │ 1:1                          │
         ▼                              │
┌─────────────────────────┐             │
│  OrderLocalStateEntity  │─────────────┘
│   (本地状态表)           │
├─────────────────────────┤
│ PK/FK: order_id         │
│ local_status [索引]      │
│ local_start_timestamp   │
│ face_verification_completed │
│ needs_sync              │
└─────────────────────────┘
         │
         │ 1:N
         ▼
┌─────────────────────────┐    ┌─────────────────────────┐
│  OrderProjectEntity     │    │   OrderImageEntity      │
│  (订单项目关联表)        │    │  (订单图片表)            │
├─────────────────────────┤    ├─────────────────────────┤
│ PK: id                  │    │ PK: id                  │
│ FK: order_id [索引]      │    │ FK: order_id [索引]     │
│ project_id [联合唯一]    │    │ image_type [联合索引]    │
│ project_name            │    │ upload_status [索引]     │
│ is_selected [索引]       │    └─────────────────────────┘
└─────────────────────────┘
         │
         │ 1:N
         ▼
┌─────────────────────────┐
│  OrderLocationEntity    │
│  (订单定位记录表)        │
├─────────────────────────┤
│ PK: id                  │
│ FK: order_id [索引]      │
│ latitude, longitude     │
│ upload_status [索引]     │
└─────────────────────────┘
```

##### 1. 订单主实体 (OrderEntity) - 仅订单核心信息

```kotlin
@Entity(
    tableName = "orders",
    indices = [
        Index(value = ["plan_id"]),
        Index(value = ["state"])
    ]
)
data class OrderEntity(
    @PrimaryKey
    @ColumnInfo(name = "order_id")
    val orderId: Long,
    
    // ========== 订单基本信息 ==========
    @ColumnInfo(name = "plan_id", defaultValue = "0")
    val planId: Int = 0,
    
    @ColumnInfo(name = "state", defaultValue = "0")
    val state: Int = 0,
    
    @ColumnInfo(name = "start_time", defaultValue = "")
    val startTime: String = "",
    
    @ColumnInfo(name = "end_time", defaultValue = "")
    val endTime: String = "",
    
    // ========== 同步元数据 ==========
    @ColumnInfo(name = "last_sync_time", defaultValue = "0")
    val lastSyncTime: Long = 0L,
    
    @ColumnInfo(name = "created_at", defaultValue = "0")
    val createdAt: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "updated_at", defaultValue = "0")
    val updatedAt: Long = System.currentTimeMillis()
)
```

##### 2. 订单老人信息实体 (OrderElderInfoEntity) - 老人相关信息

```kotlin
@Entity(
    tableName = "order_elder_info",
    foreignKeys = [
        ForeignKey(
            entity = OrderEntity::class,
            parentColumns = ["order_id"],
            childColumns = ["order_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["order_id"], unique = true),
        Index(value = ["elder_user_id"])
    ]
)
data class OrderElderInfoEntity(
    @PrimaryKey
    @ColumnInfo(name = "order_id")
    val orderId: Long,
    
    // ========== 老人基本信息 ==========
    @ColumnInfo(name = "elder_user_id", defaultValue = "0")
    val elderUserId: Int = 0,
    
    @ColumnInfo(name = "elder_name", defaultValue = "")
    val elderName: String = "",
    
    @ColumnInfo(name = "elder_id_card", defaultValue = "")
    val elderIdCard: String = "",
    
    @ColumnInfo(name = "elder_age", defaultValue = "0")
    val elderAge: Int = 0,
    
    @ColumnInfo(name = "elder_gender", defaultValue = "")
    val elderGender: String = "",
    
    // ========== 老人地址信息 ==========
    @ColumnInfo(name = "elder_address", defaultValue = "")
    val elderAddress: String = "",
    
    @ColumnInfo(name = "elder_lng", defaultValue = "")
    val elderLng: String = "",
    
    @ColumnInfo(name = "elder_lat", defaultValue = "")
    val elderLat: String = "",
    
    // ========== 服务统计信息 ==========
    @ColumnInfo(name = "last_service_time", defaultValue = "")
    val lastServiceTime: String = "",
    
    @ColumnInfo(name = "month_service_time", defaultValue = "0")
    val monthServiceTime: Int = 0,
    
    @ColumnInfo(name = "month_no_service_time", defaultValue = "0")
    val monthNoServiceTime: Int = 0,
    
    // ========== 时间戳 ==========
    @ColumnInfo(name = "created_at", defaultValue = "0")
    val createdAt: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "updated_at", defaultValue = "0")
    val updatedAt: Long = System.currentTimeMillis()
)
```

##### 3. 订单本地状态实体 (OrderLocalStateEntity) - 仅本地数据

```kotlin
@Entity(
    tableName = "order_local_states",
    foreignKeys = [
        ForeignKey(
            entity = OrderEntity::class,
            parentColumns = ["order_id"],
            childColumns = ["order_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["order_id"], unique = true),
        Index(value = ["local_status"])
    ]
)
data class OrderLocalStateEntity(
    @PrimaryKey
    @ColumnInfo(name = "order_id")
    val orderId: Long,
    
    // ========== 本地服务状态 ==========
    @ColumnInfo(name = "local_status", defaultValue = "PENDING")
    val localStatus: String = LocalOrderStatus.PENDING,
    
    @ColumnInfo(name = "local_start_timestamp")
    val localStartTimestamp: Long? = null,
    
    @ColumnInfo(name = "local_end_timestamp")
    val localEndTimestamp: Long? = null,
    
    // ========== 人脸验证状态 ==========
    @ColumnInfo(name = "face_verification_completed", defaultValue = "0")
    val faceVerificationCompleted: Boolean = false,
    
    // ========== 同步标记 ==========
    @ColumnInfo(name = "needs_sync", defaultValue = "0")
    val needsSync: Boolean = false,
    
    // ========== 时间戳 ==========
    @ColumnInfo(name = "created_at", defaultValue = "0")
    val createdAt: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "updated_at", defaultValue = "0")
    val updatedAt: Long = System.currentTimeMillis()
)
```

##### 4. 订单项目关联表 (OrderProjectEntity)

```kotlin
@Entity(
    tableName = "order_projects",
    foreignKeys = [
        ForeignKey(
            entity = OrderEntity::class,
            parentColumns = ["order_id"],
            childColumns = ["order_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["order_id"]),
        Index(value = ["order_id", "project_id"], unique = true),
        Index(value = ["is_selected"])
    ]
)
data class OrderProjectEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0L,
    
    @ColumnInfo(name = "order_id")
    val orderId: Long,
    
    // ========== 服务端数据 ==========
    @ColumnInfo(name = "project_id")
    val projectId: Int,
    
    @ColumnInfo(name = "project_name", defaultValue = "")
    val projectName: String = "",
    
    @ColumnInfo(name = "service_time", defaultValue = "0")
    val serviceTime: Int = 0,
    
    @ColumnInfo(name = "last_service_time", defaultValue = "")
    val lastServiceTime: String = "",
    
    @ColumnInfo(name = "is_complete", defaultValue = "0")
    val isComplete: Int = 0,
    
    // ========== 本地数据 ==========
    @ColumnInfo(name = "is_selected", defaultValue = "0")
    val isSelected: Boolean = false,
    
    // 时间戳
    @ColumnInfo(name = "created_at", defaultValue = "0")
    val createdAt: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "updated_at", defaultValue = "0")
    val updatedAt: Long = System.currentTimeMillis()
)
```

##### 5. 订单图片实体 (OrderImageEntity)

```kotlin
@Entity(
    tableName = "order_images",
    foreignKeys = [
        ForeignKey(
            entity = OrderEntity::class,
            parentColumns = ["order_id"],
            childColumns = ["order_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["order_id"]),
        Index(value = ["order_id", "image_type"]),
        Index(value = ["upload_status"])
    ]
)
data class OrderImageEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0L,
    
    @ColumnInfo(name = "order_id")
    val orderId: Long,
    
    @ColumnInfo(name = "image_type")
    val imageType: String,  // CUSTOMER, BEFORE_CARE, CENTER_CARE, AFTER_CARE
    
    @ColumnInfo(name = "local_uri")
    val localUri: String,
    
    @ColumnInfo(name = "local_path")
    val localPath: String? = null,
    
    @ColumnInfo(name = "upload_status", defaultValue = "PENDING")
    val uploadStatus: String = "PENDING",  // PENDING, UPLOADING, SUCCESS, FAILED, CANCELLED
    
    @ColumnInfo(name = "cloud_key")
    val cloudKey: String? = null,
    
    @ColumnInfo(name = "cloud_url")
    val cloudUrl: String? = null,
    
    @ColumnInfo(name = "error_message")
    val errorMessage: String? = null,
    
    @ColumnInfo(name = "created_at", defaultValue = "0")
    val createdAt: Long = System.currentTimeMillis(),
    
    @ColumnInfo(name = "updated_at", defaultValue = "0")
    val updatedAt: Long = System.currentTimeMillis()
)
```

##### 6. 订单定位实体 (OrderLocationEntity)

```kotlin
@Entity(
    tableName = "order_locations",
    foreignKeys = [
        ForeignKey(
            entity = OrderEntity::class,
            parentColumns = ["order_id"],
            childColumns = ["order_id"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["order_id"]),
        Index(value = ["upload_status"])
    ]
)
data class OrderLocationEntity(
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    val id: Long = 0L,
    
    @ColumnInfo(name = "order_id")
    val orderId: Long,
    
    @ColumnInfo(name = "latitude")
    val latitude: Double,
    
    @ColumnInfo(name = "longitude")
    val longitude: Double,
    
    @ColumnInfo(name = "accuracy", defaultValue = "0")
    val accuracy: Float = 0f,
    
    @ColumnInfo(name = "provider", defaultValue = "")
    val provider: String = "",
    
    @ColumnInfo(name = "upload_status", defaultValue = "PENDING")
    val uploadStatus: String = "PENDING",  // PENDING, SUCCESS, FAILED
    
    @ColumnInfo(name = "timestamp", defaultValue = "0")
    val timestamp: Long = System.currentTimeMillis()
)
```

##### 5. 订单DAO - 提供订单数据访问

```kotlin
@Dao
interface OrderDao {
    // ========== 查询 ==========
    
    @Query("SELECT * FROM orders WHERE orderId = :orderId")
    suspend fun getByOrderId(orderId: Long): OrderEntity?
    
    @Query("SELECT * FROM orders WHERE orderId = :orderId")
    fun observeByOrderId(orderId: Long): Flow<OrderEntity?>
    
    @Query("SELECT * FROM orders WHERE localStatus = :status")
    fun observeByStatus(status: String): Flow<List<OrderEntity>>
    
    @Query("SELECT * FROM orders WHERE localStatus = 'IN_PROGRESS' LIMIT 1")
    suspend fun getActiveOrder(): OrderEntity?
    
    @Query("SELECT * FROM orders WHERE localStatus = 'IN_PROGRESS' LIMIT 1")
    fun observeActiveOrder(): Flow<OrderEntity?>
    
    // ========== 写入 ==========
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(order: OrderEntity)
    
    @Update
    suspend fun update(order: OrderEntity)
    
    @Query("UPDATE orders SET localStatus = :status, localStartTimestamp = :startTime, updatedAt = :timestamp WHERE orderId = :orderId")
    suspend fun startService(orderId: Long, status: String = "IN_PROGRESS", startTime: Long = System.currentTimeMillis(), timestamp: Long = System.currentTimeMillis())
    
    @Query("UPDATE orders SET localStatus = :status, localEndTimestamp = :endTime, updatedAt = :timestamp WHERE orderId = :orderId")
    suspend fun endService(orderId: Long, status: String = "COMPLETED", endTime: Long = System.currentTimeMillis(), timestamp: Long = System.currentTimeMillis())
    
    @Query("UPDATE orders SET faceVerificationCompleted = 1, updatedAt = :timestamp WHERE orderId = :orderId")
    suspend fun markFaceVerified(orderId: Long, timestamp: Long = System.currentTimeMillis())
    
    // ========== 删除 ==========
    
    @Query("DELETE FROM orders WHERE orderId = :orderId")
    suspend fun delete(orderId: Long)
    
    @Query("DELETE FROM orders WHERE localStatus = 'COMPLETED' AND updatedAt < :timestamp")
    suspend fun deleteOldCompleted(timestamp: Long)
}
```

##### 6. 项目DAO - 提供项目数据访问（替代JSON字段）

```kotlin
@Dao
interface OrderProjectDao {
    // ========== 查询 ==========
    
    @Query("SELECT * FROM order_projects WHERE orderId = :orderId ORDER BY projectId")
    suspend fun getProjectsByOrderId(orderId: Long): List<OrderProjectEntity>
    
    @Query("SELECT * FROM order_projects WHERE orderId = :orderId ORDER BY projectId")
    fun observeProjectsByOrderId(orderId: Long): Flow<List<OrderProjectEntity>>
    
    @Query("SELECT * FROM order_projects WHERE orderId = :orderId AND isSelected = 1")
    suspend fun getSelectedProjects(orderId: Long): List<OrderProjectEntity>
    
    @Query("SELECT * FROM order_projects WHERE orderId = :orderId AND isSelected = 1")
    fun observeSelectedProjects(orderId: Long): Flow<List<OrderProjectEntity>>
    
    @Query("SELECT projectId FROM order_projects WHERE orderId = :orderId AND isSelected = 1")
    suspend fun getSelectedProjectIds(orderId: Long): List<Int>
    
    // ========== 写入 ==========
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdate(project: OrderProjectEntity)
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrUpdateAll(projects: List<OrderProjectEntity>)
    
    @Query("UPDATE order_projects SET isSelected = :selected, updatedAt = :timestamp WHERE orderId = :orderId AND projectId = :projectId")
    suspend fun updateSelection(orderId: Long, projectId: Int, selected: Boolean, timestamp: Long = System.currentTimeMillis())
    
    // 批量更新选中状态：先全部取消，再选中指定的
    @Transaction
    suspend fun updateSelectedProjects(orderId: Long, selectedProjectIds: List<Int>) {
        clearAllSelections(orderId)
        selectedProjectIds.forEach { projectId ->
            updateSelection(orderId, projectId, true)
        }
    }
    
    @Query("UPDATE order_projects SET isSelected = 0 WHERE orderId = :orderId")
    suspend fun clearAllSelections(orderId: Long)
    
    // ========== 删除 ==========
    
    @Query("DELETE FROM order_projects WHERE orderId = :orderId")
    suspend fun deleteByOrderId(orderId: Long)
}
```

##### 7. 图片DAO

```kotlin
@Dao
interface OrderImageDao {
    @Insert
    suspend fun insert(image: OrderImageEntity): Long
    
    @Update
    suspend fun update(image: OrderImageEntity)
    
    @Query("SELECT * FROM order_images WHERE orderId = :orderId AND imageType = :type ORDER BY createdAt")
    suspend fun getImagesByType(orderId: Long, type: String): List<OrderImageEntity>
    
    @Query("SELECT * FROM order_images WHERE orderId = :orderId AND imageType = :type ORDER BY createdAt")
    fun observeImagesByType(orderId: Long, type: String): Flow<List<OrderImageEntity>>
    
    @Query("SELECT * FROM order_images WHERE orderId = :orderId AND uploadStatus = 'SUCCESS'")
    suspend fun getUploadedImages(orderId: Long): List<OrderImageEntity>
    
    @Query("DELETE FROM order_images WHERE id = :id")
    suspend fun deleteById(id: Long)
    
    @Query("UPDATE order_images SET uploadStatus = 'CANCELLED' WHERE id = :id")
    suspend fun cancelUpload(id: Long)
    
    @Query("UPDATE order_images SET uploadStatus = :status, cloudKey = :cloudKey, cloudUrl = :cloudUrl, updatedAt = :timestamp WHERE id = :id")
    suspend fun updateUploadStatus(id: Long, status: String, cloudKey: String? = null, cloudUrl: String? = null, timestamp: Long = System.currentTimeMillis())
    
    @Query("SELECT cloudKey FROM order_images WHERE orderId = :orderId AND imageType = :type AND uploadStatus = 'SUCCESS'")
    suspend fun getUploadedKeysByType(orderId: Long, type: String): List<String>
}
```

#### 统一订单仓库 (UnifiedOrderRepository)

```kotlin
/**
 * 统一订单仓库
 * 职责：
 * 1. 作为订单数据的唯一入口
 * 2. 协调API调用和本地数据库同步
 * 3. 提供Flow供UI订阅数据变化
 */
@Singleton
class UnifiedOrderRepository @Inject constructor(
    private val apiService: LongCareApiService,
    private val orderDao: OrderDao,
    private val projectDao: OrderProjectDao,
    private val imageDao: OrderImageDao,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) {
    // ========== 订单查询 ==========
    
    fun observeOrder(orderId: Long): Flow<OrderEntity?> {
        return orderDao.observeByOrderId(orderId)
    }
    
    fun observeActiveOrder(): Flow<OrderEntity?> {
        return orderDao.observeActiveOrder()
    }
    
    // ========== 项目查询（替代JSON字段） ==========
    
    fun observeProjects(orderId: Long): Flow<List<OrderProjectEntity>> {
        return projectDao.observeProjectsByOrderId(orderId)
    }
    
    fun observeSelectedProjects(orderId: Long): Flow<List<OrderProjectEntity>> {
        return projectDao.observeSelectedProjects(orderId)
    }
    
    suspend fun getSelectedProjectIds(orderId: Long): List<Int> {
        return projectDao.getSelectedProjectIds(orderId)
    }
    
    // ========== 数据同步（核心方法） ==========
    
    /**
     * 同步获取订单（先尝试本地，再网络）
     * 同时同步项目列表到关联表
     */
    suspend fun getOrder(orderId: Long, planId: Int, forceRefresh: Boolean = false): ApiResult<OrderEntity> {
        return withContext(ioDispatcher) {
            // 1. 检查本地缓存
            if (!forceRefresh) {
                val cached = orderDao.getByOrderId(orderId)
                if (cached != null && isDataFresh(cached)) {
                    return@withContext ApiResult.Success(cached)
                }
            }
            
            // 2. 从API获取
            try {
                val response = apiService.getOrderInfo(OrderInfoParamModel(orderId, planId))
                if (response.isSuccessful && response.body() != null) {
                    val apiModel = response.body()!!
                    
                    // 3. 事务保存订单和项目
                    saveOrderWithProjects(orderId, planId, apiModel)
                    
                    val entity = orderDao.getByOrderId(orderId)!!
                    return@withContext ApiResult.Success(entity)
                } else {
                    return@withContext ApiResult.Failure(response.code(), response.message())
                }
            } catch (e: Exception) {
                val cached = orderDao.getByOrderId(orderId)
                if (cached != null) {
                    return@withContext ApiResult.Success(cached)
                }
                return@withContext ApiResult.Exception(e)
            }
        }
    }
    
    /**
     * 保存订单及其项目列表（事务操作）
     */
    @Transaction
    private suspend fun saveOrderWithProjects(orderId: Long, planId: Int, apiModel: ServiceOrderInfoModel) {
        // 1. 保存订单主表
        val orderEntity = OrderEntity(
            orderId = apiModel.orderId,
            planId = planId,
            state = apiModel.state,
            startTime = apiModel.startTime,
            endTime = apiModel.endTime,
            elderUserId = apiModel.userInfo?.userId ?: 0,
            elderName = apiModel.userInfo?.name ?: "",
            elderIdCard = apiModel.userInfo?.identityCardNumber ?: "",
            elderAge = apiModel.userInfo?.age ?: 0,
            elderGender = apiModel.userInfo?.gender ?: "",
            elderAddress = apiModel.userInfo?.address ?: "",
            elderLng = apiModel.userInfo?.lng ?: "",
            elderLat = apiModel.userInfo?.lat ?: "",
            lastServiceTime = apiModel.userInfo?.lastServiceTime ?: "",
            monthServiceTime = apiModel.userInfo?.monthServiceTime ?: 0,
            monthNoServiceTime = apiModel.userInfo?.monthNoServiceTime ?: 0,
            lastSyncTime = System.currentTimeMillis()
        )
        orderDao.insertOrUpdate(orderEntity)
        
        // 2. 保存项目列表到关联表（保留本地的isSelected状态）
        val existingProjects = projectDao.getProjectsByOrderId(orderId)
        val selectedIds = existingProjects.filter { it.isSelected }.map { it.projectId }.toSet()
        
        val projectEntities = apiModel.projectList?.map { project ->
            OrderProjectEntity(
                orderId = orderId,
                projectId = project.projectId,
                projectName = project.projectName,
                serviceTime = project.serviceTime,
                lastServiceTime = project.lastServiceTime,
                isComplete = project.isComplete,
                isSelected = selectedIds.contains(project.projectId)  // 保留本地选中状态
            )
        } ?: emptyList()
        
        // 先删除旧的，再插入新的
        projectDao.deleteByOrderId(orderId)
        projectDao.insertOrUpdateAll(projectEntities)
    }
    
    // ========== 本地状态更新 ==========
    
    suspend fun startService(orderId: Long) {
        orderDao.startService(orderId)
    }
    
    suspend fun endService(orderId: Long) {
        orderDao.endService(orderId)
    }
    
    /**
     * 更新选中的项目（使用关联表，无需JSON）
     */
    suspend fun updateSelectedProjects(orderId: Long, projectIds: List<Int>) {
        projectDao.updateSelectedProjects(orderId, projectIds)
    }
    
    suspend fun markFaceVerified(orderId: Long) {
        orderDao.markFaceVerified(orderId)
    }
    
    // ========== 辅助方法 ==========
    
    private fun isDataFresh(order: OrderEntity): Boolean {
        val ageMs = System.currentTimeMillis() - order.lastSyncTime
        return ageMs < 5 * 60 * 1000 // 5分钟内认为是新鲜的
    }
}
```

#### 页面导航简化 [COMPLETED ✓]

**改造前**：
```kotlin
// 传递完整对象
data class ServiceRoute(val orderInfoRequest: OrderInfoRequestModel)
navController.navigate(ServiceRoute(OrderInfoRequestModel(orderId, planId)))
```

**改造后**：
```kotlin
// 使用导航参数模型
@Serializable
data class OrderNavParams(
    val orderId: Long,
    val planId: Int = 0
)

data class ServiceRoute(val orderParams: OrderNavParams)
navController.navigateToService(OrderNavParams(orderId, planId))

// 页面中从orderParams获取订单ID和计划ID
@Composable
fun ServiceScreen(orderParams: OrderNavParams) {
    val orderInfoRequest = remember(orderParams) {
        OrderInfoRequestModel(orderId = orderParams.orderId, planId = orderParams.planId)
    }
    // 使用orderInfoRequest获取订单数据
}
```

#### ViewModel改造示例

```kotlin
@HiltViewModel
class ServiceViewModel @Inject constructor(
    private val orderRepository: UnifiedOrderRepository
) : ViewModel() {
    
    private val _orderId = MutableStateFlow<Long?>(null)
    
    // 订阅数据库中的订单数据，数据变化时自动更新
    val order: StateFlow<OrderEntity?> = _orderId
        .filterNotNull()
        .flatMapLatest { orderId ->
            orderRepository.observeOrder(orderId)
        }
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), null)
    
    fun loadOrder(orderId: Long) {
        _orderId.value = orderId
        
        // 后台刷新数据
        viewModelScope.launch {
            orderRepository.getOrder(orderId, planId = 0, forceRefresh = false)
        }
    }
    
    // 更新选中项目 - 直接操作数据库
    fun updateSelectedProjects(projectIds: List<Int>) {
        viewModelScope.launch {
            _orderId.value?.let { orderId ->
                orderRepository.updateSelectedProjects(orderId, projectIds)
            }
        }
    }
}
```

---

### 2.2 本地存储重新设计

#### 方案概述

使用 **Room数据库** 作为核心存储，统一管理所有订单相关数据：

```
┌─────────────────────────────────────────────────────────────┐
│                      LongCareDatabase                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────┐     ┌──────────────────────────────┐  │
│  │   OrderEntity    │────▶│   OrderImageEntity           │  │
│  └──────────────────┘     └──────────────────────────────┘  │
│         │                                                    │
│         │                 ┌──────────────────────────────┐  │
│         └────────────────▶│   OrderLocationEntity        │  │
│                           └──────────────────────────────┘  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 数据库配置（重要）

> [!IMPORTANT]
> **数据库安全策略**：
> 1. 开启Room自动迁移方案，简化版本升级
> 2. 数据库异常时自动删除重建，保证程序稳定性

##### 1. LongCareDatabase 配置

```kotlin
@Database(
    entities = [
        OrderEntity::class,
        OrderProjectEntity::class,   // 新增：项目关联表
        OrderImageEntity::class,
        OrderLocationEntity::class
    ],
    version = 1,
    exportSchema = true,  // 导出Schema用于自动迁移
    autoMigrations = [
        // 后续版本升级时添加自动迁移
        // AutoMigration(from = 1, to = 2),
    ]
)
abstract class LongCareDatabase : RoomDatabase() {
    
    abstract fun orderDao(): OrderDao
    abstract fun orderProjectDao(): OrderProjectDao  // 新增
    abstract fun orderImageDao(): OrderImageDao
    abstract fun orderLocationDao(): OrderLocationDao
    
    companion object {
        const val DATABASE_NAME = "longcare_database"
    }
}
```

##### 2. 数据库提供（Hilt Module）

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideLongCareDatabase(
        @ApplicationContext context: Context
    ): LongCareDatabase {
        return Room.databaseBuilder(
            context,
            LongCareDatabase::class.java,
            LongCareDatabase.DATABASE_NAME
        )
        // ========== 自动迁移配置 ==========
        // 允许Room自动处理简单的Schema变更（如添加列）
        // 复杂变更（如删除列、修改类型）仍需手动Migration
        
        // ========== 异常处理策略 ==========
        // 当数据库损坏或迁移失败时，删除数据库并重建
        // 这保证了应用的稳定性，避免因数据库问题导致崩溃
        .fallbackToDestructiveMigration()
        
        // 可选：仅在降级时删除重建（测试时可能需要）
        // .fallbackToDestructiveMigrationOnDowngrade()
        
        // 可选：添加迁移失败回调，用于日志记录
        .addCallback(object : RoomDatabase.Callback() {
            override fun onDestructiveMigration(db: SupportSQLiteDatabase) {
                super.onDestructiveMigration(db)
                // 记录日志，方便排查问题
                Log.w("LongCareDatabase", "Database was recreated due to migration failure")
            }
        })
        .build()
    }
    
    @Provides
    fun provideOrderDao(database: LongCareDatabase): OrderDao {
        return database.orderDao()
    }
    
    @Provides
    fun provideOrderProjectDao(database: LongCareDatabase): OrderProjectDao {
        return database.orderProjectDao()
    }
    
    @Provides
    fun provideOrderImageDao(database: LongCareDatabase): OrderImageDao {
        return database.orderImageDao()
    }
    
    @Provides
    fun provideOrderLocationDao(database: LongCareDatabase): OrderLocationDao {
        return database.orderLocationDao()
    }
}
```

##### 3. 自动迁移使用示例

当需要升级数据库版本时（如添加新字段）：

```kotlin
// 1. 修改Entity，添加新字段
@Entity(tableName = "orders")
data class OrderEntity(
    // ... 现有字段
    
    // 新增字段，必须有默认值
    @ColumnInfo(defaultValue = "")
    val newField: String = ""
)

// 2. 更新数据库版本，添加AutoMigration
@Database(
    entities = [...],
    version = 2,  // 版本号 +1
    autoMigrations = [
        AutoMigration(from = 1, to = 2)  // 添加自动迁移
    ]
)
abstract class LongCareDatabase : RoomDatabase() { ... }
```

##### 4. 复杂迁移场景

对于无法自动迁移的情况（如删除列、重命名列），需要提供迁移规格：

```kotlin
// 定义迁移规格类
@DeleteColumn(tableName = "orders", columnName = "oldField")
@RenameColumn(tableName = "orders", fromColumnName = "oldName", toColumnName = "newName")
class Migration2To3Spec : AutoMigrationSpec

// 在Database注解中引用
autoMigrations = [
    AutoMigration(from = 2, to = 3, spec = Migration2To3Spec::class)
]
```

> [!TIP]
> **配置 build.gradle.kts 以导出Schema**：
> ```kotlin
> ksp {
>     arg("room.schemaLocation", "$projectDir/schemas")
> }
> ```
> 这将在 `app/schemas/` 目录下生成每个版本的JSON Schema文件，Room会根据这些文件自动生成迁移代码。

#### 数据模型设计

##### 1. 订单会话实体 (OrderSessionEntity)

```kotlin
@Entity(tableName = "order_sessions")
data class OrderSessionEntity(
    @PrimaryKey
    val orderId: Long,
    
    // 用户信息
    val userId: Int,
    
    // 服务时间
    val serviceStartTime: Long? = null,      // 服务开始时间戳
    val serviceEndTime: Long? = null,        // 服务结束时间戳
    val systemBootTime: Long? = null,        // 系统启动时间（用于重启检测）
    
    // 项目选择
    val selectedProjectIds: String = "",     // JSON格式的项目ID列表
    
    // 人脸验证
    val faceVerificationStatus: Boolean = false,
    
    // 服务状态
    val status: String = "PENDING",          // PENDING, IN_PROGRESS, COMPLETED, CANCELLED
    
    // 时间戳
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis()
)
```

##### 2. 订单图片实体 (OrderImageEntity)

```kotlin
@Entity(
    tableName = "order_images",
    foreignKeys = [
        ForeignKey(
            entity = OrderSessionEntity::class,
            parentColumns = ["orderId"],
            childColumns = ["orderId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("orderId")]
)
data class OrderImageEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    val orderId: Long,
    
    // 图片类型
    val imageType: String,  // CUSTOMER, BEFORE_CARE, CENTER_CARE, AFTER_CARE
    
    // 本地信息
    val localUri: String,              // 本地文件URI
    val localPath: String? = null,     // 本地文件路径
    
    // 上传状态
    val uploadStatus: String = "PENDING",  // PENDING, UPLOADING, SUCCESS, FAILED, CANCELLED
    val cloudKey: String? = null,          // COS上的Key
    val cloudUrl: String? = null,          // COS访问URL
    
    // 错误信息
    val errorMessage: String? = null,
    
    // 元数据
    val createdAt: Long = System.currentTimeMillis(),
    val updatedAt: Long = System.currentTimeMillis()
)
```

##### 3. 订单定位实体 (OrderLocationEntity)

```kotlin
@Entity(
    tableName = "order_locations",
    foreignKeys = [
        ForeignKey(
            entity = OrderSessionEntity::class,
            parentColumns = ["orderId"],
            childColumns = ["orderId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("orderId")]
)
data class OrderLocationEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    
    val orderId: Long,
    
    // 位置信息
    val latitude: Double,
    val longitude: Double,
    val accuracy: Float = 0f,
    val provider: String = "",
    
    // 上传状态
    val uploadStatus: String = "PENDING",  // PENDING, SUCCESS, FAILED
    
    // 时间戳
    val timestamp: Long = System.currentTimeMillis()
)
```

#### DAO设计

```kotlin
@Dao
interface OrderSessionDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(session: OrderSessionEntity)
    
    @Update
    suspend fun update(session: OrderSessionEntity)
    
    @Query("SELECT * FROM order_sessions WHERE orderId = :orderId")
    suspend fun getByOrderId(orderId: Long): OrderSessionEntity?
    
    @Query("SELECT * FROM order_sessions WHERE userId = :userId AND status = 'IN_PROGRESS'")
    suspend fun getActiveSessionForUser(userId: Int): OrderSessionEntity?
    
    @Query("DELETE FROM order_sessions WHERE orderId = :orderId")
    suspend fun delete(orderId: Long)
    
    @Query("DELETE FROM order_sessions WHERE status = 'COMPLETED' AND updatedAt < :timestamp")
    suspend fun deleteOldCompletedSessions(timestamp: Long)
}

@Dao
interface OrderImageDao {
    @Insert
    suspend fun insert(image: OrderImageEntity): Long
    
    @Update
    suspend fun update(image: OrderImageEntity)
    
    @Query("SELECT * FROM order_images WHERE orderId = :orderId AND imageType = :type ORDER BY createdAt")
    suspend fun getImagesByType(orderId: Long, type: String): List<OrderImageEntity>
    
    @Query("SELECT * FROM order_images WHERE orderId = :orderId AND uploadStatus = 'SUCCESS'")
    suspend fun getUploadedImages(orderId: Long): List<OrderImageEntity>
    
    @Query("DELETE FROM order_images WHERE id = :id")
    suspend fun deleteById(id: Long)
    
    @Query("UPDATE order_images SET uploadStatus = 'CANCELLED' WHERE orderId = :orderId AND id = :imageId")
    suspend fun cancelUpload(orderId: Long, imageId: Long)
    
    @Query("SELECT cloudKey FROM order_images WHERE orderId = :orderId AND imageType = :type AND uploadStatus = 'SUCCESS'")
    suspend fun getUploadedKeysByType(orderId: Long, type: String): List<String>
}
```

#### Repository层

```kotlin
@Singleton
class OrderSessionRepository @Inject constructor(
    private val sessionDao: OrderSessionDao,
    private val imageDao: OrderImageDao,
    private val locationDao: OrderLocationDao
) {
    /**
     * 创建或获取订单会话
     */
    suspend fun getOrCreateSession(orderId: Long, userId: Int): OrderSessionEntity {
        return sessionDao.getByOrderId(orderId) ?: OrderSessionEntity(
            orderId = orderId,
            userId = userId
        ).also { sessionDao.insert(it) }
    }
    
    /**
     * 添加图片并返回实体（用于跟踪上传状态）
     */
    suspend fun addImage(
        orderId: Long,
        imageType: String,
        localUri: String
    ): OrderImageEntity {
        val image = OrderImageEntity(
            orderId = orderId,
            imageType = imageType,
            localUri = localUri,
            uploadStatus = "PENDING"
        )
        val id = imageDao.insert(image)
        return image.copy(id = id)
    }
    
    /**
     * 取消图片（用户删除了图片）
     */
    suspend fun cancelImage(orderId: Long, imageId: Long) {
        imageDao.cancelUpload(orderId, imageId)
    }
    
    /**
     * 更新图片上传状态
     */
    suspend fun updateImageUploadStatus(
        imageId: Long,
        status: String,
        cloudKey: String? = null,
        cloudUrl: String? = null,
        errorMessage: String? = null
    ) {
        val image = // 获取并更新
        imageDao.update(image.copy(
            uploadStatus = status,
            cloudKey = cloudKey,
            cloudUrl = cloudUrl,
            errorMessage = errorMessage,
            updatedAt = System.currentTimeMillis()
        ))
    }
    
    /**
     * 获取结束服务时需要提交的图片Key列表
     */
    suspend fun getSubmitImageKeys(orderId: Long): Map<String, List<String>> {
        return mapOf(
            "BEFORE_CARE" to imageDao.getUploadedKeysByType(orderId, "BEFORE_CARE"),
            "CENTER_CARE" to imageDao.getUploadedKeysByType(orderId, "CENTER_CARE"),
            "AFTER_CARE" to imageDao.getUploadedKeysByType(orderId, "AFTER_CARE")
        )
    }
}
```

#### 迁移策略

1. **Phase 1**: 创建Room数据库和实体
2. **Phase 2**: 创建迁移工具，将SharedPreferences中的现有数据迁移到Room
3. **Phase 3**: 修改现有Manager类使用新的Repository
4. **Phase 4**: 删除旧的SharedPreferences相关代码

---

### 2.2 定位服务优化

#### 方案概述

将定位模式从**单次请求**改为**持续监听**模式，使用回调方式获取最新位置：

```
┌──────────────────────────────────────────────────────────────┐
│                  LocationStateManager                         │
│                     (单例，全局位置状态)                        │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────┐      ┌─────────────────────────────┐    │
│  │ currentLocation │◀─────│ CompositeLocationProvider   │    │
│  │   StateFlow     │      │     (持续监听模式)           │    │
│  └─────────────────┘      └─────────────────────────────┘    │
│         │                                                     │
│         ▼                                                     │
│  ┌─────────────────┐                                         │
│  │ 使用方直接读取   │                                         │
│  │ 无需等待获取     │                                         │
│  └─────────────────┘                                         │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

#### 核心类设计

##### 1. LocationStateManager (位置状态管理器)

```kotlin
@Singleton
class LocationStateManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val amapLocationManager: ContinuousAmapLocationManager
) {
    // 当前位置状态
    private val _currentLocation = MutableStateFlow<LocationState>(LocationState.Unknown)
    val currentLocation: StateFlow<LocationState> = _currentLocation.asStateFlow()
    
    // 位置更新时间
    private val _lastUpdateTime = MutableStateFlow<Long>(0L)
    val lastUpdateTime: StateFlow<Long> = _lastUpdateTime.asStateFlow()
    
    // 是否正在监听
    private val _isListening = MutableStateFlow(false)
    val isListening: StateFlow<Boolean> = _isListening.asStateFlow()
    
    /**
     * 开始持续定位
     */
    fun startLocationUpdates() {
        if (_isListening.value) return
        
        _isListening.value = true
        amapLocationManager.startContinuousLocation { result ->
            result?.let {
                _currentLocation.value = LocationState.Available(
                    latitude = it.latitude,
                    longitude = it.longitude,
                    accuracy = it.accuracy,
                    provider = it.provider,
                    timestamp = System.currentTimeMillis()
                )
                _lastUpdateTime.value = System.currentTimeMillis()
            }
        }
    }
    
    /**
     * 停止持续定位
     */
    fun stopLocationUpdates() {
        _isListening.value = false
        amapLocationManager.stopLocation()
    }
    
    /**
     * 获取当前位置（立即返回，不阻塞）
     * 用于NFC签到等需要即时获取位置的场景
     */
    fun getCurrentLocationOrNull(): LocationResult? {
        return when (val state = _currentLocation.value) {
            is LocationState.Available -> LocationResult(
                latitude = state.latitude,
                longitude = state.longitude,
                provider = state.provider,
                accuracy = state.accuracy
            )
            else -> null
        }
    }
    
    /**
     * 获取当前位置（等待最多5秒）
     * 如果已有位置直接返回，否则等待新位置
     */
    suspend fun getCurrentLocation(timeoutMs: Long = 5000): LocationResult? {
        // 如果已有有效位置（2分钟内），直接返回
        val currentState = _currentLocation.value
        if (currentState is LocationState.Available) {
            val age = System.currentTimeMillis() - currentState.timestamp
            if (age < 120_000) {  // 2分钟内的位置认为有效
                return LocationResult(
                    latitude = currentState.latitude,
                    longitude = currentState.longitude,
                    provider = currentState.provider,
                    accuracy = currentState.accuracy
                )
            }
        }
        
        // 等待新位置
        return withTimeoutOrNull(timeoutMs) {
            _currentLocation.first { it is LocationState.Available } as? LocationState.Available
        }?.let {
            LocationResult(
                latitude = it.latitude,
                longitude = it.longitude,
                provider = it.provider,
                accuracy = it.accuracy
            )
        }
    }
}

sealed class LocationState {
    object Unknown : LocationState()
    object Disabled : LocationState()
    data class Available(
        val latitude: Double,
        val longitude: Double,
        val accuracy: Float,
        val provider: String,
        val timestamp: Long
    ) : LocationState()
}
```

##### 2. ContinuousAmapLocationManager (持续定位管理器)

```kotlin
@Singleton
class ContinuousAmapLocationManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val systemConfigManager: SystemConfigManager
) {
    private var locationClient: AMapLocationClient? = null
    private var locationCallback: ((LocationResult?) -> Unit)? = null
    
    /**
     * 开始持续定位
     */
    fun startContinuousLocation(callback: (LocationResult?) -> Unit) {
        locationCallback = callback
        
        val third = systemConfigManager.getThirdKey()
        val apiKey = third?.gaoDeMapApiKey?.takeIf { it.isNotBlank() } ?: return
        
        initLocationClient(apiKey)
        
        locationClient?.setLocationOption(AMapLocationClientOption().apply {
            locationMode = AMapLocationClientOption.AMapLocationMode.Hight_Accuracy
            isOnceLocation = false              // 持续定位
            interval = 10000                    // 10秒间隔
            isNeedAddress = false
            isMockEnable = false
            httpTimeOut = 15000
        })
        
        locationClient?.setLocationListener { location ->
            if (location != null && location.errorCode == 0) {
                val result = LocationResult(
                    latitude = location.latitude,
                    longitude = location.longitude,
                    provider = "amap",
                    accuracy = location.accuracy
                )
                locationCallback?.invoke(result)
            }
        }
        
        locationClient?.startLocation()
    }
    
    /**
     * 停止定位
     */
    fun stopLocation() {
        locationClient?.stopLocation()
        locationCallback = null
    }
    
    /**
     * 销毁
     */
    fun destroy() {
        stopLocation()
        locationClient?.onDestroy()
        locationClient = null
    }
    
    private fun initLocationClient(apiKey: String) {
        if (locationClient != null) return
        
        AMapLocationClient.setApiKey(apiKey)
        AMapLocationClient.updatePrivacyShow(context, true, true)
        AMapLocationClient.updatePrivacyAgree(context, true)
        
        locationClient = AMapLocationClient(context)
    }
}
```

##### 3. 集成到服务流程

```kotlin
// NfcWorkflowViewModel.kt 中的使用方式

@HiltViewModel
class NfcWorkflowViewModel @Inject constructor(
    private val locationStateManager: LocationStateManager,
    // ... 其他依赖
) : ViewModel() {

    init {
        // ViewModel创建时开始监听位置
        locationStateManager.startLocationUpdates()
    }
    
    override fun onCleared() {
        super.onCleared()
        // 注意：不在这里停止，因为服务可能还在进行
    }
    
    /**
     * 处理NFC扫描事件 - 使用缓存位置，无需等待
     */
    fun handleNfcScan(tagId: String, signInMode: SignInMode) {
        viewModelScope.launch {
            // 直接获取缓存的位置，最多等待5秒
            val location = locationStateManager.getCurrentLocation(5000)
            
            if (location == null) {
                showError("无法获取位置信息，请确保已开启定位服务")
                return@launch
            }
            
            when (signInMode) {
                SignInMode.START_ORDER -> startOrder(tagId, location)
                SignInMode.END_ORDER -> endOrder(tagId, location)
            }
        }
    }
}
```

##### 4. 服务期间持续上报

```kotlin
// LocationTrackingService.kt 改造

@AndroidEntryPoint
class LocationTrackingService : Service() {
    
    @Inject
    lateinit var locationStateManager: LocationStateManager
    
    @Inject
    lateinit var locationRepository: LocationRepository
    
    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START -> {
                val orderId = intent.getLongExtra(EXTRA_ORDER_ID, -1L)
                if (orderId != -1L) {
                    startTracking(orderId)
                }
            }
            ACTION_STOP -> stopTracking()
        }
        return START_NOT_STICKY
    }
    
    private fun startTracking(orderId: Long) {
        // 确保位置监听已启动
        locationStateManager.startLocationUpdates()
        
        // 订阅位置变化，定期上报
        serviceScope.launch {
            while (isActive) {
                // 获取当前位置
                val location = locationStateManager.getCurrentLocationOrNull()
                
                if (location != null) {
                    // 上报位置
                    locationRepository.addPosition(
                        orderId,
                        location.latitude,
                        location.longitude
                    )
                }
                
                delay(30_000L)  // 30秒上报一次
            }
        }
    }
}
```

---

### 2.4 用户信息存储方案评估

> [!NOTE]
> **评估结论**：当前用户信息存储方案**无需更改**。

#### 现有方案分析

| 组件 | 职责 | 存储方式 |
|-----|------|---------|
| `UserSessionRepository` | 管理用户会话状态 | DataStore + Protobuf |
| `DefaultUserSessionRepository` | 会话状态持久化实现 | StateFlow 响应式 |
| `UserSpecificDataStoreManager` | 多用户数据隔离 | 按userId独立DataStore |

#### 保留原因

1. **职责清晰**：专门处理用户会话，与订单数据存储分离
2. **技术选型合理**：DataStore + Protobuf 适合存储单一用户配置信息
3. **已提供StateFlow**：符合响应式编程模式，与新架构一致
4. **用户隔离支持**：`UserSpecificDataStoreManager` 支持多用户场景

#### 与新方案的关系

```
┌────────────────────────────────────────────────────────────┐
│                        存储层划分                           │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  用户会话数据 (保持不变)          订单业务数据 (本次优化)     │
│  ┌─────────────────────┐       ┌─────────────────────┐    │
│  │  UserSessionRepo    │       │ UnifiedOrderRepo     │    │
│  │  (DataStore+Proto)  │       │ (Room Database)      │    │
│  ├─────────────────────┤       ├─────────────────────┤    │
│  │ - 用户登录信息       │       │ - 订单详情           │    │
│  │ - 用户Token         │       │ - 项目列表           │    │
│  │ - 用户偏好设置       │       │ - 图片状态           │    │
│  └─────────────────────┘       │ - 定位记录           │    │
│                                └─────────────────────┘    │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

## 三、实施计划

### 3.1 阶段划分

| 阶段 | 任务 | 预估工时 | 优先级 |
|-----|------|---------|-------|
| **Phase 1** | Room数据库设计和核心实体创建 | 2天 | ✅ 已完成 |
| **Phase 2** | UnifiedOrderRepository实现（订单同步核心） | 2天 | ✅ 已完成 |
| **Phase 3** | 图片管理改造 | 2天 | ✅ 已完成 |
| **Phase 4** | 导航改造（使用OrderNavParams） | 3天 | ✅ 已完成 |
| **Phase 5** | 定位持续监听模式实现 | 2天 | 高 |
| **Phase 6** | 删除旧Manager类代码 | 2天 | 中 |
| **Phase 7** | 测试验证 | 2天 | 中 |

> [!TIP]
> **注意**：数据迁移不需要处理，Phase 6 只需删除旧的相关逻辑代码即可。

### 3.2 详细任务说明

#### Phase 1: Room数据库设计和核心实体创建 [COMPLETED ✓]

> [!NOTE]
> 已创建完整的Room数据库架构，包含6个实体和6个DAO。

- ✅ 创建 `LongCareDatabase.kt`
- ✅ 创建 `OrderEntity.kt`（订单核心信息）
- ✅ 创建 `OrderElderInfoEntity.kt`（老人信息）
- ✅ 创建 `OrderLocalStateEntity.kt`（本地状态）
- ✅ 创建 `OrderProjectEntity.kt`（服务项目）
- ✅ 创建 `OrderImageEntity.kt`（图片状态跟踪）
- ✅ 创建 `OrderLocationEntity.kt`（定位记录）
- ✅ 创建 `OrderDao.kt`、`OrderElderInfoDao.kt`、`OrderLocalStateDao.kt`
- ✅ 创建 `OrderProjectDao.kt`、`OrderImageDao.kt`、`OrderLocationDao.kt`
- ✅ 创建 `DatabaseModule.kt`（Hilt DI配置）
- ✅ 编译验证通过

#### Phase 2: UnifiedOrderRepository实现 [COMPLETED ✓]

> [!NOTE]
> 已实现统一订单仓库，套用API调用→数据库同步→Flow订阅模式。

- ✅ 创建 `OrderStatusConstants.kt`（状态枚举统一管理）
- ✅ 创建 `OrderMapper.kt`（API响应→数据库实体映射）
- ✅ 创建 `UnifiedOrderRepository.kt`
- ✅ 实现API调用→数据库同步逻辑
- ✅ 提供Flow供UI订阅
- ✅ 编译验证通过

#### Phase 3: 图片管理改造 [COMPLETED ✓]

> [!NOTE]
> 已创建ImageRepository并重构PhotoProcessingViewModel使用Room持久化。

- ✅ 创建 `ImageRepository.kt` 统一管理图片操作
- ✅ 图片状态机管理（PENDING, UPLOADING, SUCCESS, FAILED, CANCELLED）
- ✅ 改造 `PhotoProcessingViewModel` 使用Room
- ✅ 实现图片状态持久化（增删改同步Room）
- ✅ 编译验证通过

#### Phase 4: 导航改造 [COMPLETED ✓]

> [!NOTE]
> 实际实现使用 `OrderNavParams(orderId, planId)` 模型而非只传 `orderId`，以支持护理计划场景。

- ✅ 创建 `OrderNavParams` 数据类（包含 orderId 和 planId）
- ✅ 修改所有Route类，改为接收 `orderParams: OrderNavParams`
- ✅ 修改所有导航扩展函数，接收 `OrderNavParams` 参数
- ✅ 修改所有Screen签名，使用 `orderParams: OrderNavParams`
- ✅ 修复所有调用位置（MainDashboard, Nursing, ServiceOrdersList等）
- ✅ 编译验证通过
- [ ] 移除 `OrderInfoRequestModelNavType.kt`（后续清理）

#### Phase 5: 定位持续监听模式

- 创建 `LocationStateManager`
- 创建 `ContinuousAmapLocationManager`
- 改造 `LocationTrackingService`
- 改造 `NfcWorkflowViewModel` 使用新定位方式

#### Phase 6: 删除旧Manager类代码

> [!CAUTION]
> 此阶段需要在前面阶段全部完成并验证通过后进行

- ✂️ 删除 `ServiceTimeManager.kt` 及其引用
- ✂️ 删除 `SelectedProjectsManager.kt` 及其引用
- ✂️ 删除 `UploadedImagesManager.kt` 及其引用
- ✂️ 删除 `FaceVerificationStatusManager.kt` 及其引用
- ✂️ 删除 `SharedOrderRepository.kt` 及其引用
- ✂️ 删除 `OrderInfoRequestModelNavType.kt`（导航序列化器）

#### Phase 7: 测试验证

- 功能测试：完整服务流程测试
- 边界情况测试：网络断开、位置关闭、应用被杀死
- 性能测试：数据库查询效率、内存占用
- 回归测试：确保现有功能不受影响

### 3.3 文件变更清单

#### 新增文件

```
app/src/main/kotlin/com/ytone/longcare/
├── data/
│   └── database/
│       ├── LongCareDatabase.kt
│       ├── entity/
│       │   ├── OrderEntity.kt              # 订单主实体（含服务端+本地数据）
│       │   ├── OrderImageEntity.kt         # 图片实体
│       │   └── OrderLocationEntity.kt      # 定位记录实体
│       ├── dao/
│       │   ├── OrderDao.kt                 # 订单DAO
│       │   ├── OrderImageDao.kt            # 图片DAO
│       │   └── OrderLocationDao.kt         # 定位DAO
│       ├── converter/
│       │   └── TypeConverters.kt           # Room类型转换器
│       └── repository/
│           └── UnifiedOrderRepository.kt   # 统一订单仓库
├── features/
│   └── location/
│       └── manager/
│           ├── LocationStateManager.kt     # 位置状态管理器
│           └── ContinuousAmapLocationManager.kt  # 持续定位管理器
```

#### 修改文件

**导航相关（Phase 4，已完成）：**
```
- navigation/NavigationRoutes.kt           (所有Route改为接收OrderNavParams)
- navigation/AppNavigation.kt              (更新composable传递OrderNavParams)
- navigation/OrderNavParams.kt             (新增：导航参数模型)
```

**ViewModel相关（Phase 4）：**
```
- shared/vm/SharedOrderDetailViewModel.kt  (改用UnifiedOrderRepository)
- features/nfc/vm/NfcWorkflowViewModel.kt
- features/servicecountdown/vm/ServiceCountdownViewModel.kt
- features/endservice/vm/EndServiceSelectionViewModel.kt
- features/photoupload/viewmodel/PhotoProcessingViewModel.kt
- features/identification/vm/IdentificationViewModel.kt
```

**废弃文件（Phase 6完成后）：**
```
- common/utils/ServiceTimeManager.kt         (功能移入UnifiedOrderRepository)
- common/utils/SelectedProjectsManager.kt    (功能移入UnifiedOrderRepository)
- common/utils/UploadedImagesManager.kt      (功能移入OrderImageDao)
- common/utils/FaceVerificationStatusManager.kt  (功能移入UnifiedOrderRepository)
- domain/order/SharedOrderRepository.kt      (被UnifiedOrderRepository替代)
```

**DI相关：**
```
- di/StorageModule.kt                        (添加Room Database提供)
- di/RepositoryModule.kt                     (添加UnifiedOrderRepository绑定)
```
---

## 四、预期收益

### 4.1 订单数据同步收益

| 指标 | 优化前 | 优化后 |
|-----|-------|-------|
| 数据来源 | 多处缓存，可能不一致 | 数据库唯一来源 |
| 导航参数 | 传递完整对象（orderId+planId+序列化） | 传递 `OrderNavParams(orderId, planId)` |
| 离线支持 | 无（内存缓存丢失） | 支持（数据库持久化） |
| 数据同步 | 各页面各自调用API | 统一Repository管理 |
| 代码复杂度 | 高（需要管理缓存一致性） | 低（Flow自动通知更新） |

### 4.2 存储优化收益

| 指标 | 优化前 | 优化后 |
|-----|-------|-------|
| 数据一致性 | 分散存储，易丢失 | 统一事务，ACID保证 |
| 图片状态跟踪 | JSON序列化，无法追踪历史 | 完整状态机，可追溯 |
| 取消/重传处理 | 可能残留旧数据 | CANCELLED状态明确标记 |
| 查询效率 | 全量反序列化 | SQL索引查询 |
| 应用被杀死 | 部分数据丢失 | 完整恢复 |

### 4.3 定位优化收益

| 指标 | 优化前 | 优化后 |
|-----|-------|-------|
| 首次获取时间 | 10-30秒 | <1秒（有缓存时） |
| 获取成功率 | 依赖单次请求 | 持续更新，更可靠 |
| 位置实时性 | 请求时获取 | 持续更新（10秒间隔） |
| NFC签到体验 | 需要等待定位 | 立即获取缓存位置 |

### 4.4 代码质量收益

| 指标 | 优化前 | 优化后 |
|-----|-------|-------|
| 可维护性 | 多个Manager分散管理 | 统一Repository |
| 可测试性 | 依赖SharedPreferences | 可用Room内存数据库测试 |
| 代码量 | 多个类，重复逻辑 | 集中管理，减少重复 |
| 扩展性 | 新增字段需修改多处 | 只需修改Entity |

---

## 五、风险与注意事项

1. **电量消耗**: 持续定位会增加电量消耗，需要在服务结束后及时停止
2. **权限处理**: 确保后台定位权限正确处理
3. **测试覆盖**: 需要充分测试各种边界情况（网络断开、位置关闭、应用被杀死等）
4. **导航改造风险**: 涉及多个页面修改，需要逐步进行，确保每个页面正常工作后再进行下一个
5. **删除旧代码风险**: 确保所有引用都已切换到新实现后再删除旧Manager类
6. **Room数据库管理**: 
   - ✅ 已配置 `exportSchema = true` 和 `AutoMigration` 支持自动迁移
   - ✅ 已配置 `fallbackToDestructiveMigration()` 在异常时自动删除重建
   - ⚠️ 添加新字段时必须设置默认值
   - ⚠️ 复杂迁移（删除列、重命名）需要提供 `AutoMigrationSpec`

---

## 六、结论

通过本方案的实施：

1. **解决图片不一致问题**: 使用Room数据库统一管理图片状态，支持取消/重传场景，明确的状态机防止数据残留
2. **解决定位延迟问题**: 使用持续监听模式，NFC扫描时可立即获取位置，无需等待
3. **解决数据来源不一致问题**: Room数据库作为唯一本地数据源，API调用自动同步更新，所有页面从同一数据源读取
4. **简化导航**: 页面间只传递 `orderId`，移除复杂的对象序列化，降低导航相关的bug风险
5. **提升代码可维护性**: 统一的数据存储方案，清晰的数据模型，减少Manager类数量

> [!TIP]
> 建议按照Phase顺序逐步实施。**Phase 1-2** 是基础，完成后可并行进行 **Phase 3-5**。最后进行 **Phase 6-7** 的迁移和清理工作。每个阶段完成后进行充分测试，确保功能正常后再进入下一阶段。
