# 护理服务App问题分析报告

## 问题概述

用户报告了三个主要问题，需要进行代码分析和排查：

1. **服务状态异常**: 杨文均13点35分服务开始，在15点37分服务结束时碰一碰登出，结果又变成开始服务了
2. **照片上传不一致**: 护工在汪月英客户上服务，App上传的服务前照片与系统后台看到的照片不一致
3. **服务定位为空**: 服务期间的定位数据是空的

---

## 问题一：服务结束后碰一碰登出又变成开始服务

### 现象描述
- 护理员杨文均在13:35开始服务，15:37时服务结束
- 使用NFC碰一碰进行登出时，系统又变成"开始服务"状态
- 护理员在不知道如何关闭的情况下拍好照片
- 再次关闭时显示"时间未到无法关闭"

### 代码分析

#### 1. NFC签到/签退流程 ([NfcWorkflowViewModel.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/features/nfc/vm/NfcWorkflowViewModel.kt))

当NFC标签被扫描时，`observeNfcEvents` 方法会根据 `signInMode` 参数来判断是开始服务还是结束服务：

```kotlin
when (signInMode) {
    SignInMode.START_ORDER -> {
        checkUserLocationAndProceed(...)  // 开始服务流程
    }
    SignInMode.END_ORDER -> {
        endOrder(...)  // 结束服务流程
    }
}
```

> [!IMPORTANT]
> **关键问题**: `signInMode` 是在页面进入时通过导航参数传入的。如果护理员从错误的入口进入NFC页面，或者页面状态被重置，就可能导致 `signInMode` 被错误设置为 `START_ORDER`。

#### 2. 结束服务校验 ([OrderRepository.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/domain/order/OrderRepository.kt))

结束服务前会调用 `checkEndOrder` 进行校验：

```kotlin
suspend fun checkEndOrder(
    orderId: Long,
    projectIdList: List<Int>
): ApiResult<Unit>
```

> [!WARNING]
> 如果 `checkEndOrder` 返回失败代码（如3005），系统会弹出确认对话框让用户选择是否继续。但如果用户取消了对话框，状态会被重置为 `Initial`，而不是保持在结束服务流程中。

#### 3. 订单状态轮询 ([ServiceCountdownViewModel.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/features/servicecountdown/vm/ServiceCountdownViewModel.kt#L437-L479))

有一个每5秒轮询订单状态的机制：

```kotlin
fun startOrderStatePolling(orderId: Long) {
    orderStatePollingJob = viewModelScope.launch {
        while (true) {
            delay(ORDER_STATE_POLLING_INTERVAL)  // 5秒
            
            when (val result = orderRepository.getOrderState(orderId)) {
                is ApiResult.Success -> {
                    if (!orderState.isInProgress()) {
                        _orderStateError.value = orderState  // 触发异常事件
                        break
                    }
                }
                // ...
            }
        }
    }
}
```

### 可能的原因

1. **导航参数丢失**: 用户可能通过后退键或应用切换后重新进入NFC页面，导致 `signInMode` 默认变为 `START_ORDER`

2. **服务端状态不同步**: 服务端可能已经将订单状态标记为"已完成"或其他状态，而客户端仍然尝试结束订单

3. **`checkEndOrder` 校验失败**: 如果时间校验不通过，服务端可能返回错误，导致客户端重置状态

4. **竞态条件**: 在结束服务的网络请求还未完成时，用户可能再次执行了NFC扫描操作

### 建议修复方案

1. **添加订单状态检查**: 在进入NFC页面前，先检查订单当前状态，如果已经是"开始服务"状态，则自动设置为结束模式
2. **持久化签到模式**: 将当前操作模式持久化存储，避免页面重建时丢失
3. **防重复操作**: 在NFC操作进行中时，禁止响应新的NFC事件

---

## 问题二：照片上传与后台显示不一致

### 现象描述
- 护工在汪月英客户处服务
- App上传的服务前照片与系统后台看到的照片不一致

### 代码分析

#### 1. 照片上传流程 ([PhotoProcessingViewModel.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/features/photoupload/viewmodel/PhotoProcessingViewModel.kt))

照片上传的核心流程：

```kotlin
suspend fun uploadSuccessfulImagesToCloud(): Result<Map<ImageTaskType, List<String>>> {
    // 过滤出成功处理但尚未上传的图片任务
    val successfulTasks = _imageTasks.value.filter {
        it.status == ImageTaskStatus.SUCCESS && it.resultUri != null && !it.isUploaded
    }
    
    for (task in successfulTasks) {
        val uploadParams = CosUtils.createUploadParams(
            context = applicationContext,
            fileUri = uri,
            folderType = CosConstants.DEFAULT_FOLDER_TYPE
        )
        val uploadResult = cosRepository.uploadFile(uploadParams)
        
        if (uploadResult.success) {
            updateTaskUploadStatus(task.id, uploadResult.url, uploadResult.key)
        }
    }
    
    // 返回所有已上传图片的key
    return Result.success(allUploadedResults)
}
```

#### 2. 结束订单时提交照片 ([EndOrderParamModel.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/api/request/EndOrderParamModel.kt))

```kotlin
data class EndOrderParamModel(
    val orderId: Long,
    val nfc: String,
    val longitude: String,
    val latitude: String,
    val porjectIdList: List<Int>,
    val beginImgList: List<String>,    // 开始图片集合
    val centerImgList: List<String>,   // 护理中图片集合
    val endImgList: List<String>,      // 护理后图片集合
    val endType: Int
)
```

#### 3. 图片任务数据模型 ([ImageTask.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/features/photoupload/model/ImageTask.kt))

```kotlin
data class ImageTask(
    val id: String,
    val originalUri: Uri,
    val taskType: ImageTaskType,      // BEFORE_CARE, CENTER_CARE, AFTER_CARE
    val resultUri: Uri? = null,
    val status: ImageTaskStatus,
    val isUploaded: Boolean = false,
    val key: String? = null,          // 云端Key - 这是传给服务端的值
    val cloudUrl: String? = null      // 云端URL
)
```

### 可能的原因

1. **图片Key与订单不匹配**: 
   - 上传图片时生成的 `key` 可能没有正确关联到当前订单
   - 可能存在之前订单的图片被错误地提交到当前订单

2. **本地缓存问题**: 
   - `UploadedImagesManager` 使用订单ID作为key来保存已上传图片数据
   - 如果订单ID在不同情况下复用，可能会导致混淆

3. **上传未完成就提交**: 
   - 图片可能还在上传中，但用户已经进行了结束服务操作
   - 导致提交的是旧的或空的图片列表

4. **COS上传顺序问题**: 
   - 多张图片可能乱序上传完成，导致顺序与预期不符

### 需要进一步排查

1. 查看上传图片时生成的 `key` 格式是否包含订单ID
2. 检查 `CosUtils.createUploadParams` 方法的实现
3. 验证服务端接收到的 `beginImgList` 内容

---

## 问题三：服务定位为空

### 现象描述
- 服务期间，系统记录的定位数据是空的

### 代码分析

#### 1. 定位服务 ([LocationTrackingService.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/features/location/service/LocationTrackingService.kt))

定位上报是通过前台服务实现的：

```kotlin
private fun startTracking() {
    trackingJob = serviceScope.launch {
        while (isActive) {
            fetchCurrentLocation()
            delay(30_000L)  // 每30秒上报一次
        }
    }
}

private suspend fun fetchCurrentLocation() {
    val locationResult = compositeLocationProvider.getCurrentLocation()
    
    if (locationResult != null) {
        handleLocationUpdate(locationResult)
    } else {
        logE("所有定位方式都获取位置失败")
    }
}

private fun handleLocationUpdate(locationResult: LocationResult) {
    serviceScope.launch {
        locationRepository.addPosition(
            currentOrderId, 
            locationResult.latitude, 
            locationResult.longitude
        )
    }
}
```

#### 2. 定位API参数 ([AddPositionParamModel.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/api/request/AddPositionParamModel.kt))

```kotlin
data class AddPositionParamModel(
    @param:Json(name = "orderid")
    val orderId: Long = 0L,
    
    @param:Json(name = "longitude")
    val longitude: String = "",
    
    @param:Json(name = "latitude")
    val latitude: String = ""
)
```

#### 3. 定位服务启动时机 ([NfcWorkflowScreen.kt](file:///Users/wajie/StudioProjects/longcare/app/src/main/kotlin/com/ytone/longcare/features/nfc/ui/NfcWorkflowScreen.kt#L250-L251))

定位服务在签到成功后启动：

```kotlin
SignInMode.START_ORDER -> {
    // 签到成功时开启定位上报任务
    checkLocationPermissionAndStart()
    // 签到成功后跳转到身份认证页面
    navController.navigateToIdentification(orderInfoRequest)
}
```

### 可能的原因

1. **定位服务未启动**:
   - 签到成功后 `checkLocationPermissionAndStart()` 可能因权限问题未能成功启动服务
   - `LocationTrackingManager.startTracking()` 方法有状态检查，如果已经是 tracking 状态则不会启动

2. **orderId 无效**:
   - 定位服务需要有效的 `orderId` 才能启动
   - 如果 `orderId` 是 `INVALID_ORDER_ID`(-1L)，服务会立即停止

3. **定位获取失败**:
   - `CompositeLocationProvider.getCurrentLocation()` 返回 null
   - 可能是GPS未开启、权限未授予、或网络定位失败

4. **服务被系统杀死**:
   - 前台服务可能被系统杀死（低内存等原因）
   - `START_NOT_STICKY` 策略意味着服务不会自动重启

5. **定位API调用失败**:
   - 定位数据获取成功，但 `addPosition` API 调用失败
   - 目前失败时只有日志，没有重试机制

### 需要进一步排查

1. 查看设备日志确认定位服务是否正常运行
2. 确认定位权限（精确定位、后台定位）是否正确授予
3. 检查 API 请求日志，确认定位数据是否发送到服务端

---

## 建议的排查步骤

### 1. 添加日志追踪

在以下关键位置添加详细日志：
- NFC 扫描时的 `signInMode` 值
- `checkEndOrder` 的返回结果
- 照片上传时的文件路径和生成的 key
- 定位服务的启动、获取、上报全流程

### 2. 服务端日志对照

收集以下服务端数据进行对比：
- 订单状态变更记录
- 接收到的图片 key 列表
- 定位数据的接收记录

### 3. 复现问题

尝试复现问题场景，记录：
- 操作步骤
- 网络状态
- 设备型号
- App 版本

---

## 总结

| 问题 | 初步判断原因 | 紧迫性 |
|------|-------------|--------|
| 服务状态异常 | 导航参数丢失或订单状态不同步 | 高 |
| 照片不一致 | 图片Key未正确关联订单 | 高 |
| 定位为空 | 定位服务未启动或被杀死 | 中 |

需要进一步获取更多信息（日志、服务端数据、用户操作步骤）才能精确定位问题根因。
