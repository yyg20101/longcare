# 倒计时锁屏响铃问题修复说明

## 问题描述

当app切至后台并锁屏后，服务时间完成时没有通知响铃。

## 问题原因分析

### 1. AlarmManager设置策略问题
- **原问题**：代码中优先使用`setExactAndAllowWhileIdle()`，只有在没有精确闹钟权限时才使用`setAlarmClock()`
- **影响**：在Android 12+设备上，`setExactAndAllowWhileIdle()`在Doze模式下可能被延迟或跳过
- **根本原因**：`setAlarmClock()`比`setExactAndAllowWhileIdle()`更可靠，因为它：
  - 可以绕过Doze模式和App Standby
  - 在锁屏状态下也能正常触发
  - 系统会在状态栏显示闹钟图标，提高优先级

### 2. WakeLock使用不当
- **原问题**：使用`PARTIAL_WAKE_LOCK`，只保持CPU运行，不点亮屏幕
- **影响**：在锁屏状态下，用户看不到响铃提醒
- **解决方案**：使用`FULL_WAKE_LOCK`并添加`ACQUIRE_CAUSES_WAKEUP`标志，确保屏幕点亮

### 3. 权限检查逻辑问题
- **原问题**：只有在有通知权限时才设置闹钟
- **影响**：如果用户拒绝通知权限，闹钟根本不会被设置
- **解决方案**：无论权限状态都设置闹钟，只是在没有权限时显示提示

### 4. Intent标志不完整
- **原问题**：启动Activity时缺少必要的标志
- **影响**：在锁屏状态下Activity可能无法启动
- **解决方案**：添加`FLAG_ACTIVITY_NO_USER_ACTION`标志

## 修复内容

### 1. CountdownNotificationManager.kt

#### 修改1：优化闹钟设置策略
```kotlin
// 修改前：优先使用setExactAndAllowWhileIdle
val useAlarmClockFallback = (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) && !canScheduleExactAlarms()
if (useAlarmClockFallback) {
    alarmManager.setAlarmClock(alarmClockInfo, pendingIntent)
} else {
    AlarmManagerCompat.setExactAndAllowWhileIdle(...)
}

// 修改后：Android 12+优先使用setAlarmClock
val shouldUseAlarmClock = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S
if (shouldUseAlarmClock) {
    alarmManager.setAlarmClock(alarmClockInfo, pendingIntent)
} else {
    AlarmManagerCompat.setExactAndAllowWhileIdle(...)
}
```

**原因**：
- `setAlarmClock()`在Android 12+上更可靠
- 可以绕过Doze模式和电池优化
- 系统会显示闹钟图标，提高优先级

#### 修改2：添加闹钟验证日志
```kotlin
// 验证闹钟是否设置成功
val nextAlarmClock = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    alarmManager.nextAlarmClock
} else {
    null
}
logI("下一个闹钟时间: ${nextAlarmClock?.triggerTime}")
```

#### 修改3：增强取消闹钟逻辑
```kotlin
// 使用FLAG_NO_CREATE检查闹钟是否存在
val pendingIntent = PendingIntent.getBroadcast(
    context,
    COUNTDOWN_ALARM_REQUEST_CODE,
    intent,
    PendingIntent.FLAG_NO_CREATE or PendingIntent.FLAG_IMMUTABLE
)

if (pendingIntent != null) {
    alarmManager.cancel(pendingIntent)
    pendingIntent.cancel()
}
```

#### 修改4：添加唯一标识避免Intent复用
```kotlin
val intent = Intent(context, CountdownAlarmReceiver::class.java).apply {
    putExtra(EXTRA_ORDER_ID, orderId)
    putExtra(EXTRA_SERVICE_NAME, serviceName)
    action = "COUNTDOWN_ALARM_$orderId" // 添加唯一标识
}
```

### 2. CountdownAlarmReceiver.kt

#### 修改1：使用FULL_WAKE_LOCK点亮屏幕
```kotlin
// 修改前：只保持CPU运行
val wakeLock = powerManager?.newWakeLock(
    PowerManager.PARTIAL_WAKE_LOCK,
    "LongCare:CountdownAlarm"
)

// 修改后：点亮屏幕并保持唤醒
val wakeLock = powerManager?.newWakeLock(
    PowerManager.FULL_WAKE_LOCK or 
    PowerManager.ACQUIRE_CAUSES_WAKEUP or 
    PowerManager.ON_AFTER_RELEASE,
    "LongCare:CountdownAlarm"
)
```

**标志说明**：
- `FULL_WAKE_LOCK`：保持屏幕亮度和CPU运行
- `ACQUIRE_CAUSES_WAKEUP`：获取WakeLock时立即点亮屏幕
- `ON_AFTER_RELEASE`：释放后保持屏幕短暂点亮

#### 修改2：延长WakeLock持有时间
```kotlin
// 修改前：持有10秒
wakeLock?.acquire(10000)

// 修改后：持有30秒
wakeLock?.acquire(30000)
```

#### 修改3：延迟释放WakeLock
```kotlin
// 延迟释放WakeLock，确保Activity完全启动
if (wakeLock?.isHeld == true) {
    android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
        wakeLock.release()
        logI("✅ WakeLock已释放")
    }, 5000) // 5秒后释放
}
```

#### 修改4：添加Intent标志确保锁屏启动
```kotlin
val alarmIntent = CountdownAlarmActivity.createIntent(...).apply {
    flags = Intent.FLAG_ACTIVITY_NEW_TASK or 
           Intent.FLAG_ACTIVITY_CLEAR_TOP or
           Intent.FLAG_ACTIVITY_NO_USER_ACTION // 新增：允许在锁屏状态下启动
}
```

#### 修改5：增强日志输出
```kotlin
logI("========================================")
logI("🔔 收到倒计时闹钟广播")
logI("========================================")
logI("📋 订单信息: orderId=$orderId, serviceName=$serviceName")
logI("✅ WakeLock已获取")
logI("✅ 倒计时前台服务已停止")
logI("✅ 响铃服务已启动")
logI("✅ 完成通知已显示")
logI("✅ 全屏响铃Activity已启动")
```

### 3. ServiceCountdownScreen.kt

#### 修改：无论权限状态都设置闹钟
```kotlin
// 修改前：只有在有通知权限时才设置闹钟
if (checkNotificationPermission()) {
    countdownNotificationManager.scheduleCountdownAlarm(...)
} else {
    showPermissionDialog = true
}

// 修改后：无论权限状态都设置闹钟
countdownNotificationManager.scheduleCountdownAlarm(...)

// 如果没有通知权限，显示提示
if (!checkNotificationPermission()) {
    showPermissionDialog = true
}
```

## 技术原理

### AlarmManager的三种设置方式对比

| 方法 | 精确度 | 绕过Doze | 锁屏唤醒 | 系统图标 | 适用场景 |
|------|--------|----------|----------|----------|----------|
| `setExact()` | 精确 | ❌ | ❌ | ❌ | 普通定时任务 |
| `setExactAndAllowWhileIdle()` | 精确 | ✅ | ⚠️ | ❌ | 重要定时任务 |
| `setAlarmClock()` | 精确 | ✅ | ✅ | ✅ | 闹钟类应用 |

**结论**：对于需要在锁屏状态下可靠触发的倒计时提醒，应该使用`setAlarmClock()`。

### WakeLock的类型对比

| 类型 | CPU | 屏幕 | 键盘灯 | 适用场景 |
|------|-----|------|--------|----------|
| `PARTIAL_WAKE_LOCK` | ✅ | ❌ | ❌ | 后台任务 |
| `SCREEN_DIM_WAKE_LOCK` | ✅ | 🔅 | ❌ | 视频播放 |
| `SCREEN_BRIGHT_WAKE_LOCK` | ✅ | 🔆 | ❌ | 导航应用 |
| `FULL_WAKE_LOCK` | ✅ | 🔆 | ✅ | 闹钟提醒 |

**结论**：对于需要唤醒用户的闹钟提醒，应该使用`FULL_WAKE_LOCK`。

### Doze模式和App Standby

Android 6.0+引入了Doze模式和App Standby，会限制后台应用的活动：

- **Doze模式**：设备静止且屏幕关闭一段时间后进入
- **App Standby**：用户长时间未使用应用时进入

**影响**：
- 网络访问被延迟
- WakeLock被忽略
- AlarmManager被延迟（除了`setAlarmClock()`）
- JobScheduler被延迟

**解决方案**：
1. 使用`setAlarmClock()`绕过Doze模式
2. 使用`FULL_WAKE_LOCK`确保设备唤醒
3. 申请电池优化豁免（可选）

## 测试验证

### 测试场景1：正常锁屏状态
1. 启动服务倒计时
2. 按电源键锁屏
3. 等待倒计时完成
4. **预期结果**：屏幕点亮，显示响铃页面，播放声音和震动

### 测试场景2：Doze模式
1. 启动服务倒计时
2. 锁屏并静置设备30分钟（进入Doze模式）
3. 等待倒计时完成
4. **预期结果**：屏幕点亮，显示响铃页面，播放声音和震动

### 测试场景3：后台运行
1. 启动服务倒计时
2. 切换到其他应用
3. 锁屏
4. 等待倒计时完成
5. **预期结果**：屏幕点亮，显示响铃页面，播放声音和震动

### 测试场景4：无通知权限
1. 拒绝通知权限
2. 启动服务倒计时
3. 锁屏
4. 等待倒计时完成
5. **预期结果**：屏幕点亮，显示响铃页面，播放声音和震动（通知可能不显示）

### 测试场景5：电池优化
1. 在系统设置中启用电池优化
2. 启动服务倒计时
3. 锁屏并静置设备
4. 等待倒计时完成
5. **预期结果**：屏幕点亮，显示响铃页面，播放声音和震动

## 调试方法

### 1. 查看日志
```bash
# 过滤倒计时相关日志
adb logcat | grep -E "CountdownAlarm|AlarmRingtone|CountdownNotification"

# 查看AlarmManager日志
adb logcat | grep AlarmManager
```

### 2. 检查闹钟是否设置成功
```bash
# 查看系统中所有闹钟
adb shell dumpsys alarm | grep -A 10 "com.ytone.longcare"
```

### 3. 模拟Doze模式
```bash
# 进入Doze模式
adb shell dumpsys deviceidle force-idle

# 退出Doze模式
adb shell dumpsys deviceidle unforce

# 查看Doze状态
adb shell dumpsys deviceidle
```

### 4. 检查WakeLock
```bash
# 查看当前持有的WakeLock
adb shell dumpsys power | grep -A 5 "Wake Locks"
```

## 注意事项

### 1. 权限要求
确保AndroidManifest.xml中包含以下权限：
```xml
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.USE_FULL_SCREEN_INTENT" />
<uses-permission android:name="android.permission.USE_EXACT_ALARM" />
<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
```

### 2. Android版本差异
- **Android 12+**：需要`USE_EXACT_ALARM`或`SCHEDULE_EXACT_ALARM`权限
- **Android 13+**：需要运行时请求`POST_NOTIFICATIONS`权限
- **Android 10+**：需要`USE_FULL_SCREEN_INTENT`权限才能在锁屏显示Activity

### 3. 电池优化
虽然`setAlarmClock()`可以绕过Doze模式，但在某些厂商定制系统中可能仍然被限制。建议：
- 引导用户关闭电池优化
- 添加到白名单
- 使用前台服务

### 4. 厂商定制系统
某些厂商（如小米、华为、OPPO）的定制系统可能有额外的后台限制：
- 需要在系统设置中允许自启动
- 需要在系统设置中允许后台运行
- 需要在系统设置中关闭电池优化

## 参考资料

1. [Android官方文档 - AlarmManager](https://developer.android.com/reference/android/app/AlarmManager)
2. [Android官方文档 - PowerManager.WakeLock](https://developer.android.com/reference/android/os/PowerManager.WakeLock)
3. [Android官方文档 - Doze模式优化](https://developer.android.com/training/monitoring-device-state/doze-standby)
4. [Android官方文档 - 精确闹钟](https://developer.android.com/about/versions/12/behavior-changes-12#exact-alarm-permission)

## 总结

本次修复主要解决了以下问题：

1. ✅ **AlarmManager策略优化**：Android 12+优先使用`setAlarmClock()`确保锁屏可靠触发
2. ✅ **WakeLock增强**：使用`FULL_WAKE_LOCK`确保屏幕点亮
3. ✅ **权限逻辑优化**：无论权限状态都设置闹钟
4. ✅ **Intent标志完善**：添加必要标志确保锁屏启动
5. ✅ **日志增强**：添加详细日志便于调试

修复后，倒计时完成时应该能够在锁屏状态下可靠地响铃和显示提醒。

---

**修复完成时间**：2025年1月
**测试状态**：待测试
**建议测试设备**：Android 12+设备，特别是小米、华为等定制系统
